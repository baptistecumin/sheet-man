<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sheet-Man</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 656 656'%3E%3Crect width='656' height='656' rx='60' fill='white'/%3E%3Cpath d='M259.891 249.609C167.663 278.785 119.681 228.948 124.306 134.828C126.734 111.779 143.355 104.998 165.763 104.744C217.019 104.089 277.821 104.681 328.423 104.491C433.195 99.0821 526.274 144 528.323 250.962C529.217 297.629 511.822 341.869 482.741 376.813C465.487 397.77 468.908 417.503 481.559 438.989C494.821 463.179 517.018 493.791 528.274 518.446C540.418 543.206 528.401 549.903 500.904 551.594C473.047 552.988 438.18 552.946 409.859 551.678C387.916 550.896 370.007 543.164 363.101 521.594C353.492 496.199 346.079 464.615 327.684 442.749C313.851 424.348 281.982 408.545 266.121 430.538C241.602 462.946 298.898 527.065 265.657 546.227C242.806 555.481 182.785 555.143 162.257 544.495C137.484 530.467 144.981 488.678 143.566 463.812C144.284 430.622 141.919 396.714 149.311 364.073C180.863 215.933 379.574 374.447 415.329 268.729C418.729 246.715 398.729 229.771 378.581 225.652C337.356 216.462 299.574 238.666 259.976 249.588L259.891 249.609Z' fill='%230817EC'/%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --blue: #2563eb;
            --blue-dark: #1d4ed8;
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
            --green: #22c55e;
            --red: #ef4444;
            --yellow: #eab308;
        }
        body {
            font-family: 'Inter', -apple-system, system-ui, sans-serif;
            background: #0f172a;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 24px;
        }
        #start-screen { background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%); }
        .logo { width: 80px; height: 80px; margin-bottom: 20px; filter: drop-shadow(0 0 30px rgba(59, 130, 246, 0.6)); }
        .title { font-size: 28px; font-weight: 800; color: #fff; letter-spacing: -0.04em; text-shadow: 0 0 30px rgba(59, 130, 246, 0.5); text-align: center; }
        .tagline { color: #94a3b8; font-size: 15px; margin-top: 8px; text-align: center; max-width: 300px; line-height: 1.5; }
        .click-to-play {
            color: #60a5fa;
            font-size: 18px;
            font-weight: 600;
            margin-top: 40px;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        #start-screen { cursor: pointer; }
        .btn {
            background: var(--blue);
            color: #fff;
            border: none;
            height: 52px;
            padding: 0 36px;
            font-size: 16px;
            font-weight: 600;
            font-family: inherit;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.15s;
            margin-top: 28px;
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.5), 0 0 40px rgba(37, 99, 235, 0.2);
        }
        .btn:hover { box-shadow: 0 0 30px rgba(37, 99, 235, 0.7), 0 0 60px rgba(37, 99, 235, 0.3); }
        .btn:active { transform: scale(0.97); background: var(--blue-dark); }
        .hidden { display: none !important; }

        /* Leaderboard */
        .card {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 16px;
            padding: 20px;
            width: 100%;
            max-width: 300px;
            margin-top: 32px;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.1);
            backdrop-filter: blur(10px);
        }
        .card-title {
            font-size: 11px;
            font-weight: 600;
            color: #60a5fa;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 16px;
        }
        .lb-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            font-size: 14px;
        }
        .lb-row:not(:last-child) { border-bottom: 1px solid rgba(59, 130, 246, 0.1); }
        .lb-rank {
            width: 28px;
            height: 28px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            color: #60a5fa;
            margin-right: 12px;
        }
        .lb-rank.gold { background: rgba(234, 179, 8, 0.2); color: #fbbf24; }
        .lb-rank.silver { background: rgba(148, 163, 184, 0.2); color: #cbd5e1; }
        .lb-rank.bronze { background: rgba(251, 146, 60, 0.2); color: #fb923c; }
        .lb-name { flex: 1; color: #e2e8f0; font-weight: 500; }
        .lb-score { color: #60a5fa; font-weight: 600; }

        /* Game Screen - Dark theme */
        #game-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            background: #0f172a;
            overflow: hidden;
        }
        .game-instruction {
            color: #94a3b8;
            font-size: 12px;
            text-align: center;
            padding: 8px 16px 0;
            margin: 0;
        }
        .game-hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            color: #fff;
        }
        .hud-score {
            font-size: 24px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .hud-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .hud-timer {
            font-size: 14px;
            font-weight: 600;
            color: var(--slate-400);
            font-variant-numeric: tabular-nums;
        }
        .hud-timer.warning { color: var(--yellow); }
        .hud-timer.critical { color: var(--red); }
        .power-pill {
            background: var(--green);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s;
        }
        .power-pill.active { opacity: 1; transform: scale(1); }
        .game-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            border-radius: 12px;
        }

        /* Touch zones */
        .touch-layer {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template: 1fr 1fr 1fr / 1fr 1fr 1fr;
            pointer-events: none;
        }
        .touch-zone {
            pointer-events: auto;
            border-radius: 8px;
        }
        .touch-zone:active { background: rgba(255,255,255,0.05); }
        .tz-up { grid-area: 1 / 2; }
        .tz-down { grid-area: 3 / 2; }
        .tz-left { grid-area: 2 / 1; }
        .tz-right { grid-area: 2 / 3; }

        /* Mobile arrow keys */
        .mobile-controls {
            display: none;
            margin-top: 12px;
        }
        @media (max-width: 768px) {
            .mobile-controls { display: block; }
        }
        .arrow-pad {
            display: grid;
            grid-template: repeat(3, 44px) / repeat(3, 44px);
            gap: 4px;
            justify-content: center;
        }
        .arrow-btn {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            color: #60a5fa;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .arrow-btn:active { background: rgba(59, 130, 246, 0.4); }
        .arrow-up { grid-area: 1 / 2; }
        .arrow-down { grid-area: 3 / 2; }
        .arrow-left { grid-area: 2 / 1; }
        .arrow-right { grid-area: 2 / 3; }

        /* Game Over */
        #gameover-screen {
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #fff;
            display: none;
        }
        #gameover-screen .logo { filter: drop-shadow(0 0 20px rgba(59, 130, 246, 0.5)); }
        .final-score { font-size: 56px; font-weight: 800; margin: 4px 0; text-shadow: 0 0 40px rgba(59, 130, 246, 0.6); }
        .final-label { font-size: 14px; color: rgba(255,255,255,0.6); font-weight: 500; }
        .bonus-breakdown {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 16px 24px;
            margin: 20px 0;
            font-size: 14px;
        }
        .bonus-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
        }
        .bonus-row span:first-child { color: rgba(255,255,255,0.7); }
        .bonus-row span:last-child { font-weight: 600; }
        .name-input {
            width: 200px;
            height: 48px;
            padding: 0 16px;
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            background: rgba(59, 130, 246, 0.1);
            color: #fff;
            font-family: inherit;
            font-size: 15px;
            text-align: center;
            margin-top: 20px;
        }
        .name-input::placeholder { color: rgba(255,255,255,0.4); }
        .name-input:focus { outline: none; border-color: rgba(59, 130, 246, 0.6); box-shadow: 0 0 20px rgba(59, 130, 246, 0.2); }
        .btn-row { display: flex; gap: 12px; margin-top: 16px; }
        .btn-ghost {
            background: rgba(59, 130, 246, 0.2);
            color: #fff;
            border: 1px solid rgba(59, 130, 246, 0.3);
            height: 48px;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            font-family: inherit;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-ghost:hover { background: rgba(59, 130, 246, 0.3); }
        .btn-white { background: var(--blue); color: #fff; border-color: var(--blue); box-shadow: 0 0 20px rgba(37, 99, 235, 0.4); }
        .cta-text {
            margin-top: 32px;
            font-size: 13px;
            color: rgba(255,255,255,0.4);
        }
        .cta-text a { color: #60a5fa; text-decoration: none; }
    </style>
</head>
<body>
    <div id="start-screen" class="screen">
        <svg class="logo" viewBox="0 0 656 656" fill="none">
            <rect width="656" height="656" rx="60" fill="#fff"/>
            <path d="M259.891 249.609C167.663 278.785 119.681 228.948 124.306 134.828C126.734 111.779 143.355 104.998 165.763 104.744C217.019 104.089 277.821 104.681 328.423 104.491C433.195 99.0821 526.274 144 528.323 250.962C529.217 297.629 511.822 341.869 482.741 376.813C465.487 397.77 468.908 417.503 481.559 438.989C494.821 463.179 517.018 493.791 528.274 518.446C540.418 543.206 528.401 549.903 500.904 551.594C473.047 552.988 438.18 552.946 409.859 551.678C387.916 550.896 370.007 543.164 363.101 521.594C353.492 496.199 346.079 464.615 327.684 442.749C313.851 424.348 281.982 408.545 266.121 430.538C241.602 462.946 298.898 527.065 265.657 546.227C242.806 555.481 182.785 555.143 162.257 544.495C137.484 530.467 144.981 488.678 143.566 463.812C144.284 430.622 141.919 396.714 149.311 364.073C180.863 215.933 379.574 374.447 415.329 268.729C418.729 246.715 398.729 229.771 378.581 225.652C337.356 216.462 299.574 238.666 259.976 249.588L259.891 249.609Z" fill="#2563eb"/>
        </svg>
        <h1 class="title">Launch Products Faster!</h1>
        <p class="tagline">Eat the spreadsheets and clean your SKUs before time runs out.</p>
        <p class="click-to-play">Click anywhere to play</p>
        <div class="card">
            <div class="card-title">Top Scores</div>
            <div id="leaderboard"></div>
        </div>
    </div>

    <div id="gameover-screen" class="screen">
        <svg class="logo" viewBox="0 0 656 656" fill="none">
            <rect width="656" height="656" rx="60" fill="#fff"/>
            <path d="M259.891 249.609C167.663 278.785 119.681 228.948 124.306 134.828C126.734 111.779 143.355 104.998 165.763 104.744C217.019 104.089 277.821 104.681 328.423 104.491C433.195 99.0821 526.274 144 528.323 250.962C529.217 297.629 511.822 341.869 482.741 376.813C465.487 397.77 468.908 417.503 481.559 438.989C494.821 463.179 517.018 493.791 528.274 518.446C540.418 543.206 528.401 549.903 500.904 551.594C473.047 552.988 438.18 552.946 409.859 551.678C387.916 550.896 370.007 543.164 363.101 521.594C353.492 496.199 346.079 464.615 327.684 442.749C313.851 424.348 281.982 408.545 266.121 430.538C241.602 462.946 298.898 527.065 265.657 546.227C242.806 555.481 182.785 555.143 162.257 544.495C137.484 530.467 144.981 488.678 143.566 463.812C144.284 430.622 141.919 396.714 149.311 364.073C180.863 215.933 379.574 374.447 415.329 268.729C418.729 246.715 398.729 229.771 378.581 225.652C337.356 216.462 299.574 238.666 259.976 249.588L259.891 249.609Z" fill="#2563eb"/>
        </svg>
        <p class="final-label">Final Score</p>
        <p class="final-score" id="final-score">0</p>
        <div class="bonus-breakdown" id="breakdown"></div>
        <input type="text" class="name-input" id="player-name" placeholder="Your name" maxlength="15">
        <div class="btn-row">
            <button class="btn-ghost" onclick="skipSubmit()">Skip</button>
            <button class="btn-ghost btn-white" onclick="submitScore()">Save</button>
        </div>
        <button id="retry-btn" class="btn hidden" style="margin-top:16px;background:#fff;color:var(--blue)" onclick="startGame()">Play Again</button>
        <p class="cta-text">Stop playing with spreadsheets. <a href="https://rastro.ai/demo">Try Rastro</a></p>
    </div>

    <div id="game-container" class="hidden">
        <p class="game-instruction">Clean your products before time runs out.</p>
        <div class="game-hud">
            <span class="hud-score" id="hud-score">0</span>
            <div class="hud-right">
                <span class="hud-timer" id="hud-timer">2:00</span>
                <span class="power-pill" id="power-pill">DELETE FILES!</span>
            </div>
        </div>
        <div class="game-area">
            <canvas id="canvas"></canvas>
            <div class="touch-layer">
                <div class="touch-zone tz-up" data-dir="up"></div>
                <div class="touch-zone tz-left" data-dir="left"></div>
                <div class="touch-zone tz-right" data-dir="right"></div>
                <div class="touch-zone tz-down" data-dir="down"></div>
            </div>
        </div>
        <div class="mobile-controls">
            <div class="arrow-pad">
                <div class="arrow-btn arrow-up" data-dir="up">▲</div>
                <div class="arrow-btn arrow-left" data-dir="left">◀</div>
                <div class="arrow-btn arrow-right" data-dir="right">▶</div>
                <div class="arrow-btn arrow-down" data-dir="down">▼</div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://pkbcifdmebszcrpmlhxm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBrYmNpZmRtZWJzemNycG1saHhtIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NTQ0MzkwMCwiZXhwIjoyMDgxMDE5OTAwfQ.oxMxEUp7svTv_AXJC0-cLUWE7nOt5p_u2Ahxxiv98Fk';

        const CELL = 16, COLS = 19, ROWS = 21;
        const MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,2,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];

        // Colors
        const WALL_COLOR = '#1e3a5f';
        const PATH_COLOR = '#0f172a';
        const DOT_COLOR = '#475569';

        let canvas, ctx, player, enemies, dots, powerUps;
        let score = 0, enemiesEaten = 0, gameRunning = false, powered = false, powerTimer, animFrame;
        let startTime, elapsedSeconds = 0;
        let baseScore = 0, timeBonus = 0, finalScore = 0;
        const MAX_TIME = 120;

        // Floating messages
        let floatingMessages = [];
        const EAT_MESSAGES = [
            "No more spreadsheets!",
            "Data liberated!",
            "Bye bye Excel!",
            "Clean data wins!",
            "Spreadsheet deleted!",
        ];

        // Spreadsheet enemies - all variations of spreadsheets
        const ENEMIES = [
            { type: 'xls', label: '.xlsx', bg: '#217346', speed: 3 },
            { type: 'xls', label: '.xls', bg: '#1f6e43', speed: 2 },
            { type: 'csv', label: '.csv', bg: '#64748b', speed: 1 },
            { type: 'xls', label: '.gsheet', bg: '#0f9d58', speed: 2 },
        ];

        // Leaderboard
        async function fetchLeaderboard() {
            try {
                const res = await fetch(`${SUPABASE_URL}/rest/v1/sheetman_leaderboard?select=name,score&order=score.desc&limit=5`, {
                    headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
                });
                if (!res.ok) throw new Error();
                renderLeaderboard(await res.json());
            } catch { renderLeaderboard([]); }
        }

        function renderLeaderboard(data) {
            const el = document.getElementById('leaderboard');
            if (!data?.length) { el.innerHTML = '<div class="lb-row"><span style="color:var(--slate-400)">No scores yet</span></div>'; return; }
            const ranks = ['gold', 'silver', 'bronze'];
            el.innerHTML = data.map((e, i) => `
                <div class="lb-row">
                    <div class="lb-rank ${ranks[i] || ''}">${i + 1}</div>
                    <span class="lb-name">${escapeHtml(e.name)}</span>
                    <span class="lb-score">${e.score.toLocaleString()}</span>
                </div>
            `).join('');
        }

        function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }

        async function saveScore(name, score) {
            try {
                await fetch(`${SUPABASE_URL}/rest/v1/sheetman_leaderboard`, {
                    method: 'POST',
                    headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}`, 'Content-Type': 'application/json', 'Prefer': 'return=minimal' },
                    body: JSON.stringify({ name, score })
                });
                fetchLeaderboard();
            } catch {}
        }

        function isNameAppropriate(name) {
            const lower = name.toLowerCase();
            const blocked = ['fuck','shit','ass','dick','cock','pussy','bitch','nigger','faggot','cunt','whore','slut'];
            return !blocked.some(w => lower.includes(w));
        }

        function submitScore() {
            const nameInput = document.getElementById('player-name');
            const name = nameInput.value.trim() || 'Anon';

            if (!isNameAppropriate(name)) {
                nameInput.style.borderColor = '#ef4444';
                nameInput.placeholder = 'Try a different name';
                nameInput.value = '';
                return;
            }

            saveScore(name, finalScore);
            document.querySelector('.name-input').style.display = 'none';
            document.querySelector('.btn-row').style.display = 'none';
            document.querySelector('.bonus-breakdown').style.display = 'none';
            document.getElementById('retry-btn').classList.remove('hidden');
        }

        function skipSubmit() {
            document.querySelector('.name-input').style.display = 'none';
            document.querySelector('.btn-row').style.display = 'none';
            document.querySelector('.bonus-breakdown').style.display = 'none';
            document.getElementById('retry-btn').classList.remove('hidden');
        }

        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            // Make game as big as possible with crisp rendering
            const maxW = window.innerWidth - 24;
            const maxH = window.innerHeight - 80;
            const scale = Math.min(maxW / (COLS * CELL), maxH / (ROWS * CELL));
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size for crisp rendering
            canvas.width = COLS * CELL * dpr;
            canvas.height = ROWS * CELL * dpr;
            canvas.style.width = (COLS * CELL * scale) + 'px';
            canvas.style.height = (ROWS * CELL * scale) + 'px';

            // Scale context to account for device pixel ratio
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = false; // Crisp pixels

            setupControls();
            fetchLeaderboard();

            // Click anywhere on start screen to play
            document.getElementById('start-screen').addEventListener('click', startGame);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('game-container').classList.remove('hidden');
            document.querySelector('.name-input').style.display = '';
            document.querySelector('.btn-row').style.display = '';
            document.querySelector('.bonus-breakdown').style.display = '';
            document.getElementById('retry-btn').classList.add('hidden');

            score = 0; enemiesEaten = 0; powered = false; elapsedSeconds = 0;
            startTime = Date.now();
            floatingMessages = [];
            inputQueue = [];
            deathFade = 0;
            if (powerTimer) clearTimeout(powerTimer);

            player = { x: 9, y: 15, dx: 0, dy: 0, nextDx: 0, nextDy: 0, munch: 0 };
            enemies = ENEMIES.map((cfg, i) => ({
                ...cfg,
                x: 7 + i * 2,
                y: 9,
                dx: 0,
                dy: 0,
                mc: 0,
                scared: false,
                eaten: false,
                wobble: Math.random() * Math.PI * 2
            }));

            dots = []; powerUps = [];
            for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
                if (MAP[y][x] === 0) dots.push({ x, y });
                if (MAP[y][x] === 2) powerUps.push({ x, y });
            }

            updateHUD();
            gameRunning = true;
            if (animFrame) cancelAnimationFrame(animFrame);
            gameLoop();
        }

        let inputQueue = []; // Buffer for key inputs

        function setupControls() {
            document.addEventListener('keydown', e => {
                if (!gameRunning) return;
                const keys = { ArrowUp: [0,-1], ArrowDown: [0,1], ArrowLeft: [-1,0], ArrowRight: [1,0], w: [0,-1], s: [0,1], a: [-1,0], d: [1,0] };
                if (keys[e.key]) {
                    [player.nextDx, player.nextDy] = keys[e.key];
                    // Add to queue for buffered input
                    inputQueue.push({ dx: keys[e.key][0], dy: keys[e.key][1], time: Date.now() });
                    if (inputQueue.length > 3) inputQueue.shift(); // Keep last 3 inputs
                    e.preventDefault();
                }
            });
            document.querySelectorAll('.touch-zone').forEach(z => {
                z.addEventListener('touchstart', e => {
                    if (!gameRunning) return;
                    e.preventDefault();
                    const dirs = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] };
                    [player.nextDx, player.nextDy] = dirs[z.dataset.dir];
                    inputQueue.push({ dx: dirs[z.dataset.dir][0], dy: dirs[z.dataset.dir][1], time: Date.now() });
                    if (inputQueue.length > 3) inputQueue.shift();
                }, { passive: false });
            });

            // Arrow button controls for mobile
            document.querySelectorAll('.arrow-btn').forEach(btn => {
                const handler = e => {
                    if (!gameRunning) return;
                    e.preventDefault();
                    const dirs = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] };
                    [player.nextDx, player.nextDy] = dirs[btn.dataset.dir];
                    inputQueue.push({ dx: dirs[btn.dataset.dir][0], dy: dirs[btn.dataset.dir][1], time: Date.now() });
                    if (inputQueue.length > 3) inputQueue.shift();
                };
                btn.addEventListener('touchstart', handler, { passive: false });
                btn.addEventListener('mousedown', handler);
            });

            document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        }

        function canMove(x, y) {
            if (x < 0 || x >= COLS) return true;
            if (y < 0 || y >= ROWS) return false;
            return MAP[y][x] !== 1;
        }

        function tryChangeDirection() {
            // Try buffered inputs (most recent first) for responsive controls
            const now = Date.now();
            for (let i = inputQueue.length - 1; i >= 0; i--) {
                const input = inputQueue[i];
                // Only use inputs from last 500ms
                if (now - input.time > 500) {
                    inputQueue.splice(i, 1);
                    continue;
                }
                // Try to apply this direction
                if (canMove(player.x + input.dx, player.y + input.dy)) {
                    player.dx = input.dx;
                    player.dy = input.dy;
                    player.nextDx = input.dx;
                    player.nextDy = input.dy;
                    inputQueue.splice(i, 1); // Remove used input
                    break;
                }
            }

            // Also try the current nextDx/nextDy
            if (player.nextDx !== player.dx || player.nextDy !== player.dy) {
                if (canMove(player.x + player.nextDx, player.y + player.nextDy)) {
                    player.dx = player.nextDx;
                    player.dy = player.nextDy;
                }
            }
        }

        function movePlayer() {
            // Direction change is handled separately for responsiveness
            tryChangeDirection();

            if (canMove(player.x + player.dx, player.y + player.dy)) {
                player.x += player.dx; player.y += player.dy;
                player.munch++;
            }
            if (player.x < 0) player.x = COLS - 1;
            if (player.x >= COLS) player.x = 0;

            let idx = dots.findIndex(d => d.x === player.x && d.y === player.y);
            if (idx !== -1) { dots.splice(idx, 1); score += 10; updateHUD(); }

            idx = powerUps.findIndex(p => p.x === player.x && p.y === player.y);
            if (idx !== -1) { powerUps.splice(idx, 1); score += 50; activatePower(); updateHUD(); }

            if (!dots.length && !powerUps.length) { winGame(); }
        }

        function activatePower() {
            powered = true;
            enemies.forEach(e => e.scared = true);
            document.getElementById('power-pill').classList.add('active');
            if (powerTimer) clearTimeout(powerTimer);
            powerTimer = setTimeout(() => {
                powered = false;
                enemies.forEach(e => e.scared = false);
                document.getElementById('power-pill').classList.remove('active');
            }, 6000);
        }

        const SPAWN_X = 9, SPAWN_Y = 7; // Just outside ghost house

        // Move eaten enemies back to base (called every game tick)
        function moveEatenEnemies() {
            enemies.forEach(e => {
                if (!e.eaten) return;

                // Check if reached spawn
                if (Math.abs(e.x - SPAWN_X) <= 1 && Math.abs(e.y - SPAWN_Y) <= 1) {
                    e.x = SPAWN_X;
                    e.y = SPAWN_Y;
                    e.eaten = false;
                    e.scared = powered;
                    e.dx = 0;
                    e.dy = 1;
                    e.mc = 0;
                    return;
                }

                // Move towards spawn
                const dx = e.x < SPAWN_X ? 1 : e.x > SPAWN_X ? -1 : 0;
                const dy = e.y < SPAWN_Y ? 1 : e.y > SPAWN_Y ? -1 : 0;

                // Try horizontal first, then vertical
                if (dx !== 0 && canMove(e.x + dx, e.y)) {
                    e.x += dx;
                } else if (dy !== 0 && canMove(e.x, e.y + dy)) {
                    e.y += dy;
                } else if (dx !== 0) {
                    if (canMove(e.x, e.y - 1)) e.y -= 1;
                    else if (canMove(e.x, e.y + 1)) e.y += 1;
                } else if (dy !== 0) {
                    if (canMove(e.x - 1, e.y)) e.x -= 1;
                    else if (canMove(e.x + 1, e.y)) e.x += 1;
                }
            });
        }

        function moveEnemies() {
            enemies.forEach(e => {
                if (e.eaten) return; // Handled by moveEatenEnemies

                if (++e.mc < 4 - e.speed) return;
                e.mc = 0;

                const dirs = [[0,-1],[0,1],[-1,0],[1,0]].filter(d =>
                    canMove(e.x+d[0], e.y+d[1]) && !(d[0]===-e.dx && d[1]===-e.dy)
                );

                if (dirs.length) {
                    dirs.sort((a,b) => {
                        const dA = Math.abs(player.x-(e.x+a[0])) + Math.abs(player.y-(e.y+a[1]));
                        const dB = Math.abs(player.x-(e.x+b[0])) + Math.abs(player.y-(e.y+b[1]));
                        return e.scared ? dB - dA : dA - dB; // Flee when scared
                    });
                    const c = Math.random() > 0.3 ? dirs[0] : dirs[Math.floor(Math.random()*dirs.length)];
                    e.dx = c[0]; e.dy = c[1];
                }

                if (canMove(e.x + e.dx, e.y + e.dy)) { e.x += e.dx; e.y += e.dy; }
                if (e.x < 0) e.x = COLS - 1;
                if (e.x >= COLS) e.x = 0;
            });
        }

        function showFloatingMessage(x, y, text, points) {
            floatingMessages.push({
                x: x * CELL + CELL/2,
                y: y * CELL,
                text: text,
                points: points,
                opacity: 1,
                life: 60 // frames
            });
        }

        // Store previous positions for better collision detection
        let prevPlayerX, prevPlayerY;
        let prevEnemyPos = [];

        function savePositions() {
            prevPlayerX = player.x;
            prevPlayerY = player.y;
            prevEnemyPos = enemies.map(e => ({ x: e.x, y: e.y }));
        }

        function checkCollision() {
            enemies.forEach((e, i) => {
                if (e.eaten) return;

                // Current position match
                const sameCell = e.x === player.x && e.y === player.y;

                // Check if they crossed paths (swapped positions)
                const prev = prevEnemyPos[i] || { x: e.x, y: e.y };
                const crossed = (e.x === prevPlayerX && e.y === prevPlayerY &&
                                player.x === prev.x && player.y === prev.y);

                // Also check adjacent collision (within 1 cell and moving towards each other)
                const adjacent = Math.abs(e.x - player.x) + Math.abs(e.y - player.y) === 1;
                const movingTowards = adjacent && (
                    (player.dx !== 0 && player.x + player.dx === e.x && player.y === e.y) ||
                    (player.dy !== 0 && player.y + player.dy === e.y && player.x === e.x)
                );

                if (sameCell || crossed || movingTowards) {
                    if (e.scared) {
                        // Delete the file!
                        e.eaten = true;
                        enemiesEaten++;
                        const points = 200 * Math.pow(2, Math.min(enemiesEaten - 1, 3)); // 200, 400, 800, 1600
                        score += points;
                        // Time bonus for eating enemy
                        const eatBonus = 50;
                        score += eatBonus;
                        updateHUD();
                        // Show floating message
                        const msg = EAT_MESSAGES[Math.floor(Math.random() * EAT_MESSAGES.length)];
                        showFloatingMessage(e.x, e.y, msg, points);
                    } else {
                        gameOver();
                    }
                }
            });
        }

        function winGame() {
            gameRunning = false;
            calculateFinalScore(true);
        }

        function gameOver() {
            gameRunning = false;
            deathFade = 0.01; // Start fade
            animFrame = requestAnimationFrame(gameLoop);
        }

        function showGameOver() {
            baseScore = score;
            const timeLeft = Math.max(0, MAX_TIME - elapsedSeconds);
            timeBonus = Math.floor(timeLeft * 10);
            finalScore = baseScore + timeBonus;

            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('final-score').textContent = finalScore.toLocaleString();
            document.getElementById('breakdown').innerHTML = `
                <div class="bonus-row"><span>SKUs cleaned</span><span>${baseScore.toLocaleString()}</span></div>
                <div class="bonus-row"><span>Spreadsheets destroyed</span><span>${enemiesEaten}</span></div>
                <div class="bonus-row"><span>Time saved bonus</span><span>+${timeBonus.toLocaleString()}</span></div>
            `;
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('player-name').value = '';
        }

        function calculateFinalScore(won) {
            // For win, show immediately
            baseScore = score;
            const timeLeft = Math.max(0, MAX_TIME - elapsedSeconds);
            timeBonus = Math.floor(timeLeft * 10);
            finalScore = baseScore + timeBonus;

            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('final-score').textContent = finalScore.toLocaleString();
            document.getElementById('breakdown').innerHTML = `
                <div class="bonus-row"><span>SKUs cleaned</span><span>${baseScore.toLocaleString()}</span></div>
                <div class="bonus-row"><span>Spreadsheets destroyed</span><span>${enemiesEaten}</span></div>
                <div class="bonus-row"><span>Time saved bonus</span><span>+${timeBonus.toLocaleString()}</span></div>
            `;
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('player-name').value = '';
        }

        function updateHUD() {
            document.getElementById('hud-score').textContent = score.toLocaleString();
        }

        function updateTimer() {
            elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            const remaining = Math.max(0, MAX_TIME - elapsedSeconds);
            const mins = Math.floor(remaining / 60);
            const secs = remaining % 60;
            const timerEl = document.getElementById('hud-timer');
            timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            timerEl.className = 'hud-timer' + (remaining <= 30 ? ' warning' : '') + (remaining <= 10 ? ' critical' : '');

            // Time's up!
            if (remaining <= 0 && gameRunning) {
                gameOver();
            }
        }

        function draw() {
            // Dark background
            ctx.fillStyle = PATH_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Walls with glow
            ctx.fillStyle = WALL_COLOR;
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 3;
            for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
                if (MAP[y][x] === 1) {
                    ctx.beginPath();
                    ctx.roundRect(x*CELL+1, y*CELL+1, CELL-2, CELL-2, 2);
                    ctx.fill();
                }
            }
            ctx.shadowBlur = 0;

            // Dots (data points)
            ctx.fillStyle = DOT_COLOR;
            dots.forEach(d => {
                ctx.beginPath();
                ctx.arc(d.x*CELL+CELL/2, d.y*CELL+CELL/2, 2, 0, Math.PI*2);
                ctx.fill();
            });

            // Power-ups (pulsing)
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.2;
            ctx.fillStyle = '#3b82f6';
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 8;
            powerUps.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x*CELL+CELL/2, p.y*CELL+CELL/2, 5 * pulse, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Player - Rastro logo pointing in direction of travel
            const px = player.x * CELL + CELL/2;
            const py = player.y * CELL + CELL/2;
            const size = CELL;

            ctx.save();
            ctx.translate(px, py);

            // Point in direction of travel (default: right)
            if (player.dx === -1) ctx.scale(-1, 1); // Flip for left
            else if (player.dy === -1) ctx.rotate(-Math.PI/2); // Up
            else if (player.dy === 1) ctx.rotate(Math.PI/2); // Down

            // Draw actual Rastro logo using the SVG path
            ctx.fillStyle = powered ? '#22c55e' : '#3b82f6';
            ctx.shadowColor = powered ? '#22c55e' : '#3b82f6';
            ctx.shadowBlur = 8;

            // Scale the logo path to fit in cell (original viewBox is 656x656)
            const logoScale = size / 656;
            ctx.scale(logoScale, logoScale);
            ctx.translate(-328, -328); // Center the logo

            // Rastro R logo path
            ctx.beginPath();
            ctx.moveTo(259.891, 249.609);
            ctx.bezierCurveTo(167.663, 278.785, 119.681, 228.948, 124.306, 134.828);
            ctx.bezierCurveTo(126.734, 111.779, 143.355, 104.998, 165.763, 104.744);
            ctx.bezierCurveTo(217.019, 104.089, 277.821, 104.681, 328.423, 104.491);
            ctx.bezierCurveTo(433.195, 99.0821, 526.274, 144, 528.323, 250.962);
            ctx.bezierCurveTo(529.217, 297.629, 511.822, 341.869, 482.741, 376.813);
            ctx.bezierCurveTo(465.487, 397.77, 468.908, 417.503, 481.559, 438.989);
            ctx.bezierCurveTo(494.821, 463.179, 517.018, 493.791, 528.274, 518.446);
            ctx.bezierCurveTo(540.418, 543.206, 528.401, 549.903, 500.904, 551.594);
            ctx.bezierCurveTo(473.047, 552.988, 438.18, 552.946, 409.859, 551.678);
            ctx.bezierCurveTo(387.916, 550.896, 370.007, 543.164, 363.101, 521.594);
            ctx.bezierCurveTo(353.492, 496.199, 346.079, 464.615, 327.684, 442.749);
            ctx.bezierCurveTo(313.851, 424.348, 281.982, 408.545, 266.121, 430.538);
            ctx.bezierCurveTo(241.602, 462.946, 298.898, 527.065, 265.657, 546.227);
            ctx.bezierCurveTo(242.806, 555.481, 182.785, 555.143, 162.257, 544.495);
            ctx.bezierCurveTo(137.484, 530.467, 144.981, 488.678, 143.566, 463.812);
            ctx.bezierCurveTo(144.284, 430.622, 141.919, 396.714, 149.311, 364.073);
            ctx.bezierCurveTo(180.863, 215.933, 379.574, 374.447, 415.329, 268.729);
            ctx.bezierCurveTo(418.729, 246.715, 398.729, 229.771, 378.581, 225.652);
            ctx.bezierCurveTo(337.356, 216.462, 299.574, 238.666, 259.976, 249.588);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;

            // Enemies - Spreadsheet icons
            enemies.forEach(e => {
                const ex = e.x * CELL + CELL/2;
                const ey = e.y * CELL + CELL/2;

                if (e.eaten) {
                    // Show faint ghost returning to base (like Pac-Man eyes)
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = e.bg;
                    ctx.beginPath();
                    ctx.roundRect(ex - CELL/3, ey - CELL/3, CELL * 0.66, CELL * 0.66, 3);
                    ctx.fill();
                    // Small label
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${Math.floor(CELL * 0.25)}px Inter, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(e.label, ex, ey);
                    ctx.restore();
                    return;
                }

                const wobble = Math.sin(Date.now() / 150 + e.wobble) * 1.5;

                ctx.save();
                ctx.translate(ex, ey + wobble);

                // Spreadsheet dimensions - almost fill the cell
                const sw = CELL - 2;
                const sh = CELL - 2;

                // Shadow/glow
                ctx.shadowColor = e.scared ? '#3b82f6' : e.bg;
                ctx.shadowBlur = 6;

                // Main spreadsheet body (white or blue when scared)
                ctx.fillStyle = e.scared ? '#1e40af' : '#fff';
                ctx.beginPath();
                ctx.roundRect(-sw/2, -sh/2, sw, sh, 2);
                ctx.fill();

                ctx.shadowBlur = 0;

                // Header row (colored)
                ctx.fillStyle = e.scared ? '#60a5fa' : e.bg;
                ctx.beginPath();
                ctx.roundRect(-sw/2, -sh/2, sw, sh * 0.25, [2, 2, 0, 0]);
                ctx.fill();

                // Grid lines
                ctx.strokeStyle = e.scared ? 'rgba(96,165,250,0.4)' : 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 0.5;

                // Horizontal lines (3 rows)
                for (let i = 1; i <= 3; i++) {
                    const y = -sh/2 + (sh * i / 4);
                    ctx.beginPath();
                    ctx.moveTo(-sw/2, y);
                    ctx.lineTo(sw/2, y);
                    ctx.stroke();
                }

                // Vertical lines (2 columns)
                for (let i = 1; i <= 2; i++) {
                    const x = -sw/2 + (sw * i / 3);
                    ctx.beginPath();
                    ctx.moveTo(x, -sh/2 + sh * 0.25);
                    ctx.lineTo(x, sh/2);
                    ctx.stroke();
                }

                // Extension label in header
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.floor(CELL * 0.28)}px Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(e.label, 0, -sh/2 + sh * 0.125);

                ctx.restore();
            });

            // Floating messages
            floatingMessages = floatingMessages.filter(m => {
                m.life--;
                m.y -= 0.8; // Float up
                m.opacity = m.life / 60;

                if (m.life <= 0) return false;

                ctx.save();
                ctx.globalAlpha = m.opacity;
                ctx.fillStyle = '#22c55e';
                ctx.font = 'bold 10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`+${m.points}`, m.x, m.y);
                ctx.fillStyle = '#fff';
                ctx.font = '8px Inter, sans-serif';
                ctx.fillText(m.text, m.x, m.y + 10);
                ctx.restore();

                return true;
            });
        }

        let lastTime = 0;
        let lastEatenTime = 0;
        let deathFade = 0; // For fade to black on death

        function gameLoop(ts = 0) {
            if (!gameRunning) {
                // Death fade animation
                if (deathFade > 0 && deathFade < 1) {
                    deathFade += 0.02;
                    draw();
                    // Draw fade overlay
                    ctx.fillStyle = `rgba(15, 23, 42, ${deathFade})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    if (deathFade >= 1) {
                        showGameOver();
                    } else {
                        animFrame = requestAnimationFrame(gameLoop);
                    }
                }
                return;
            }
            updateTimer();
            // Check direction changes every frame for responsiveness
            tryChangeDirection();
            // Move eaten enemies back to base faster (every 50ms)
            if (ts - lastEatenTime >= 50) {
                moveEatenEnemies();
                lastEatenTime = ts;
            }

            // Game tick - 130ms for slower, more deliberate pace
            if (ts - lastTime >= 130) {
                savePositions(); // Save positions before movement
                movePlayer();
                moveEnemies();
                checkCollision();
                lastTime = ts;
            }
            // Also check collision every frame for better detection
            checkCollision();
            draw();
            animFrame = requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
