<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sheet-Man</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 656 656'%3E%3Crect width='656' height='656' rx='60' fill='white'/%3E%3Cpath d='M259.891 249.609C167.663 278.785 119.681 228.948 124.306 134.828C126.734 111.779 143.355 104.998 165.763 104.744C217.019 104.089 277.821 104.681 328.423 104.491C433.195 99.0821 526.274 144 528.323 250.962C529.217 297.629 511.822 341.869 482.741 376.813C465.487 397.77 468.908 417.503 481.559 438.989C494.821 463.179 517.018 493.791 528.274 518.446C540.418 543.206 528.401 549.903 500.904 551.594C473.047 552.988 438.18 552.946 409.859 551.678C387.916 550.896 370.007 543.164 363.101 521.594C353.492 496.199 346.079 464.615 327.684 442.749C313.851 424.348 281.982 408.545 266.121 430.538C241.602 462.946 298.898 527.065 265.657 546.227C242.806 555.481 182.785 555.143 162.257 544.495C137.484 530.467 144.981 488.678 143.566 463.812C144.284 430.622 141.919 396.714 149.311 364.073C180.863 215.933 379.574 374.447 415.329 268.729C418.729 246.715 398.729 229.771 378.581 225.652C337.356 216.462 299.574 238.666 259.976 249.588L259.891 249.609Z' fill='%230817EC'/%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --blue: #2563eb;
            --blue-dark: #1d4ed8;
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
            --green: #22c55e;
            --red: #ef4444;
            --yellow: #eab308;
        }
        body {
            font-family: 'Inter', -apple-system, system-ui, sans-serif;
            background: #0f172a;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 24px;
        }
        #start-screen { background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%); }
        .logo { width: 56px; height: 56px; margin-bottom: 12px; filter: drop-shadow(0 0 20px rgba(59, 130, 246, 0.5)); }
        .title { font-size: 32px; font-weight: 800; color: #fff; letter-spacing: -0.04em; text-shadow: 0 0 30px rgba(59, 130, 246, 0.5); }
        .tagline { color: #94a3b8; font-size: 14px; margin-top: 4px; }
        .btn {
            background: var(--blue);
            color: #fff;
            border: none;
            height: 52px;
            padding: 0 36px;
            font-size: 16px;
            font-weight: 600;
            font-family: inherit;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.15s;
            margin-top: 28px;
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.5), 0 0 40px rgba(37, 99, 235, 0.2);
        }
        .btn:hover { box-shadow: 0 0 30px rgba(37, 99, 235, 0.7), 0 0 60px rgba(37, 99, 235, 0.3); }
        .btn:active { transform: scale(0.97); background: var(--blue-dark); }
        .hidden { display: none !important; }

        /* Leaderboard */
        .card {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 16px;
            padding: 20px;
            width: 100%;
            max-width: 300px;
            margin-top: 32px;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.1);
            backdrop-filter: blur(10px);
        }
        .card-title {
            font-size: 11px;
            font-weight: 600;
            color: #60a5fa;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 16px;
        }
        .lb-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            font-size: 14px;
        }
        .lb-row:not(:last-child) { border-bottom: 1px solid rgba(59, 130, 246, 0.1); }
        .lb-rank {
            width: 28px;
            height: 28px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            color: #60a5fa;
            margin-right: 12px;
        }
        .lb-rank.gold { background: rgba(234, 179, 8, 0.2); color: #fbbf24; }
        .lb-rank.silver { background: rgba(148, 163, 184, 0.2); color: #cbd5e1; }
        .lb-rank.bronze { background: rgba(251, 146, 60, 0.2); color: #fb923c; }
        .lb-name { flex: 1; color: #e2e8f0; font-weight: 500; }
        .lb-score { color: #60a5fa; font-weight: 600; }

        /* Game Screen - Dark theme */
        #game-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            background: #0f172a;
        }
        .game-hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            color: #fff;
        }
        .hud-score {
            font-size: 24px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .hud-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .hud-timer {
            font-size: 14px;
            font-weight: 600;
            color: var(--slate-400);
            font-variant-numeric: tabular-nums;
        }
        .hud-timer.warning { color: var(--yellow); }
        .hud-timer.critical { color: var(--red); }
        .power-pill {
            background: var(--green);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s;
        }
        .power-pill.active { opacity: 1; transform: scale(1); }
        .game-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            border-radius: 12px;
        }

        /* Touch zones */
        .touch-layer {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template: 1fr 1fr 1fr / 1fr 1fr 1fr;
            pointer-events: none;
        }
        .touch-zone {
            pointer-events: auto;
            border-radius: 8px;
        }
        .touch-zone:active { background: rgba(255,255,255,0.05); }
        .tz-up { grid-area: 1 / 2; }
        .tz-down { grid-area: 3 / 2; }
        .tz-left { grid-area: 2 / 1; }
        .tz-right { grid-area: 2 / 3; }

        /* Game Over */
        #gameover-screen {
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #fff;
            display: none;
        }
        #gameover-screen .logo { filter: drop-shadow(0 0 20px rgba(59, 130, 246, 0.5)); }
        .final-score { font-size: 56px; font-weight: 800; margin: 4px 0; text-shadow: 0 0 40px rgba(59, 130, 246, 0.6); }
        .final-label { font-size: 14px; color: rgba(255,255,255,0.6); font-weight: 500; }
        .bonus-breakdown {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 16px 24px;
            margin: 20px 0;
            font-size: 14px;
        }
        .bonus-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
        }
        .bonus-row span:first-child { color: rgba(255,255,255,0.7); }
        .bonus-row span:last-child { font-weight: 600; }
        .name-input {
            width: 200px;
            height: 48px;
            padding: 0 16px;
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            background: rgba(59, 130, 246, 0.1);
            color: #fff;
            font-family: inherit;
            font-size: 15px;
            text-align: center;
            margin-top: 20px;
        }
        .name-input::placeholder { color: rgba(255,255,255,0.4); }
        .name-input:focus { outline: none; border-color: rgba(59, 130, 246, 0.6); box-shadow: 0 0 20px rgba(59, 130, 246, 0.2); }
        .btn-row { display: flex; gap: 12px; margin-top: 16px; }
        .btn-ghost {
            background: rgba(59, 130, 246, 0.2);
            color: #fff;
            border: 1px solid rgba(59, 130, 246, 0.3);
            height: 48px;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            font-family: inherit;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-ghost:hover { background: rgba(59, 130, 246, 0.3); }
        .btn-white { background: var(--blue); color: #fff; border-color: var(--blue); box-shadow: 0 0 20px rgba(37, 99, 235, 0.4); }
        .cta-text {
            margin-top: 32px;
            font-size: 13px;
            color: rgba(255,255,255,0.4);
        }
        .cta-text a { color: #60a5fa; text-decoration: none; }
    </style>
</head>
<body>
    <div id="start-screen" class="screen">
        <svg class="logo" viewBox="0 0 656 656" fill="none">
            <rect width="656" height="656" rx="60" fill="#fff"/>
            <path d="M259.891 249.609C167.663 278.785 119.681 228.948 124.306 134.828C126.734 111.779 143.355 104.998 165.763 104.744C217.019 104.089 277.821 104.681 328.423 104.491C433.195 99.0821 526.274 144 528.323 250.962C529.217 297.629 511.822 341.869 482.741 376.813C465.487 397.77 468.908 417.503 481.559 438.989C494.821 463.179 517.018 493.791 528.274 518.446C540.418 543.206 528.401 549.903 500.904 551.594C473.047 552.988 438.18 552.946 409.859 551.678C387.916 550.896 370.007 543.164 363.101 521.594C353.492 496.199 346.079 464.615 327.684 442.749C313.851 424.348 281.982 408.545 266.121 430.538C241.602 462.946 298.898 527.065 265.657 546.227C242.806 555.481 182.785 555.143 162.257 544.495C137.484 530.467 144.981 488.678 143.566 463.812C144.284 430.622 141.919 396.714 149.311 364.073C180.863 215.933 379.574 374.447 415.329 268.729C418.729 246.715 398.729 229.771 378.581 225.652C337.356 216.462 299.574 238.666 259.976 249.588L259.891 249.609Z" fill="#2563eb"/>
        </svg>
        <h1 class="title">Sheet-Man</h1>
        <p class="tagline">Stop product spreadsheet madness.</p>
        <button class="btn" onclick="startGame()">Play</button>
        <div class="card">
            <div class="card-title">Top Scores</div>
            <div id="leaderboard"></div>
        </div>
    </div>

    <div id="gameover-screen" class="screen">
        <svg class="logo" viewBox="0 0 656 656" fill="none">
            <rect width="656" height="656" rx="60" fill="#fff"/>
            <path d="M259.891 249.609C167.663 278.785 119.681 228.948 124.306 134.828C126.734 111.779 143.355 104.998 165.763 104.744C217.019 104.089 277.821 104.681 328.423 104.491C433.195 99.0821 526.274 144 528.323 250.962C529.217 297.629 511.822 341.869 482.741 376.813C465.487 397.77 468.908 417.503 481.559 438.989C494.821 463.179 517.018 493.791 528.274 518.446C540.418 543.206 528.401 549.903 500.904 551.594C473.047 552.988 438.18 552.946 409.859 551.678C387.916 550.896 370.007 543.164 363.101 521.594C353.492 496.199 346.079 464.615 327.684 442.749C313.851 424.348 281.982 408.545 266.121 430.538C241.602 462.946 298.898 527.065 265.657 546.227C242.806 555.481 182.785 555.143 162.257 544.495C137.484 530.467 144.981 488.678 143.566 463.812C144.284 430.622 141.919 396.714 149.311 364.073C180.863 215.933 379.574 374.447 415.329 268.729C418.729 246.715 398.729 229.771 378.581 225.652C337.356 216.462 299.574 238.666 259.976 249.588L259.891 249.609Z" fill="#2563eb"/>
        </svg>
        <p class="final-label">Final Score</p>
        <p class="final-score" id="final-score">0</p>
        <div class="bonus-breakdown" id="breakdown"></div>
        <input type="text" class="name-input" id="player-name" placeholder="Your name" maxlength="15">
        <div class="btn-row">
            <button class="btn-ghost" onclick="skipSubmit()">Skip</button>
            <button class="btn-ghost btn-white" onclick="submitScore()">Save</button>
        </div>
        <button id="retry-btn" class="btn hidden" style="margin-top:16px;background:#fff;color:var(--blue)" onclick="startGame()">Play Again</button>
        <p class="cta-text">Stop playing with spreadsheets. <a href="https://rastro.ai">Try Rastro</a></p>
    </div>

    <div id="game-container" class="hidden">
        <div class="game-hud">
            <span class="hud-score" id="hud-score">0</span>
            <div class="hud-right">
                <span class="hud-timer" id="hud-timer">2:00</span>
                <span class="power-pill" id="power-pill">DELETE FILES!</span>
            </div>
        </div>
        <div class="game-area">
            <canvas id="canvas"></canvas>
            <div class="touch-layer">
                <div class="touch-zone tz-up" data-dir="up"></div>
                <div class="touch-zone tz-left" data-dir="left"></div>
                <div class="touch-zone tz-right" data-dir="right"></div>
                <div class="touch-zone tz-down" data-dir="down"></div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://pkbcifdmebszcrpmlhxm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBrYmNpZmRtZWJzemNycG1saHhtIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NTQ0MzkwMCwiZXhwIjoyMDgxMDE5OTAwfQ.oxMxEUp7svTv_AXJC0-cLUWE7nOt5p_u2Ahxxiv98Fk';

        const CELL = 16, COLS = 19, ROWS = 21;
        const MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,2,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];

        // Colors
        const WALL_COLOR = '#1e3a5f';
        const PATH_COLOR = '#0f172a';
        const DOT_COLOR = '#475569';

        let canvas, ctx, player, enemies, dots, powerUps;
        let score = 0, enemiesEaten = 0, gameRunning = false, powered = false, powerTimer, animFrame;
        let startTime, elapsedSeconds = 0;
        let baseScore = 0, timeBonus = 0, finalScore = 0;
        const MAX_TIME = 120;

        // Floating messages
        let floatingMessages = [];
        const EAT_MESSAGES = [
            "No more spreadsheets!",
            "Data liberated!",
            "Bye bye Excel!",
            "Clean data wins!",
            "Spreadsheet deleted!",
        ];

        // Spreadsheet enemies - all variations of spreadsheets
        const ENEMIES = [
            { type: 'xls', label: '.xlsx', bg: '#217346', speed: 3 },
            { type: 'xls', label: '.xls', bg: '#1f6e43', speed: 2 },
            { type: 'csv', label: '.csv', bg: '#64748b', speed: 1 },
            { type: 'xls', label: '.gsheet', bg: '#0f9d58', speed: 2 },
        ];

        // Leaderboard
        async function fetchLeaderboard() {
            try {
                const res = await fetch(`${SUPABASE_URL}/rest/v1/sheetman_leaderboard?select=name,score&order=score.desc&limit=5`, {
                    headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
                });
                if (!res.ok) throw new Error();
                renderLeaderboard(await res.json());
            } catch { renderLeaderboard([]); }
        }

        function renderLeaderboard(data) {
            const el = document.getElementById('leaderboard');
            if (!data?.length) { el.innerHTML = '<div class="lb-row"><span style="color:var(--slate-400)">No scores yet</span></div>'; return; }
            const ranks = ['gold', 'silver', 'bronze'];
            el.innerHTML = data.map((e, i) => `
                <div class="lb-row">
                    <div class="lb-rank ${ranks[i] || ''}">${i + 1}</div>
                    <span class="lb-name">${escapeHtml(e.name)}</span>
                    <span class="lb-score">${e.score.toLocaleString()}</span>
                </div>
            `).join('');
        }

        function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }

        async function saveScore(name, score) {
            try {
                await fetch(`${SUPABASE_URL}/rest/v1/sheetman_leaderboard`, {
                    method: 'POST',
                    headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}`, 'Content-Type': 'application/json', 'Prefer': 'return=minimal' },
                    body: JSON.stringify({ name, score })
                });
                fetchLeaderboard();
            } catch {}
        }

        function isNameAppropriate(name) {
            const lower = name.toLowerCase();
            const blocked = ['fuck','shit','ass','dick','cock','pussy','bitch','nigger','faggot','cunt','whore','slut'];
            return !blocked.some(w => lower.includes(w));
        }

        function submitScore() {
            const nameInput = document.getElementById('player-name');
            const name = nameInput.value.trim() || 'Anon';

            if (!isNameAppropriate(name)) {
                nameInput.style.borderColor = '#ef4444';
                nameInput.placeholder = 'Try a different name';
                nameInput.value = '';
                return;
            }

            saveScore(name, finalScore);
            document.querySelector('.name-input').style.display = 'none';
            document.querySelector('.btn-row').style.display = 'none';
            document.querySelector('.bonus-breakdown').style.display = 'none';
            document.getElementById('retry-btn').classList.remove('hidden');
        }

        function skipSubmit() {
            document.querySelector('.name-input').style.display = 'none';
            document.querySelector('.btn-row').style.display = 'none';
            document.querySelector('.bonus-breakdown').style.display = 'none';
            document.getElementById('retry-btn').classList.remove('hidden');
        }

        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            // Make game as big as possible with crisp rendering
            const maxW = window.innerWidth - 24;
            const maxH = window.innerHeight - 80;
            const scale = Math.min(maxW / (COLS * CELL), maxH / (ROWS * CELL));
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size for crisp rendering
            canvas.width = COLS * CELL * dpr;
            canvas.height = ROWS * CELL * dpr;
            canvas.style.width = (COLS * CELL * scale) + 'px';
            canvas.style.height = (ROWS * CELL * scale) + 'px';

            // Scale context to account for device pixel ratio
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = false; // Crisp pixels

            setupControls();
            fetchLeaderboard();
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('game-container').classList.remove('hidden');
            document.querySelector('.name-input').style.display = '';
            document.querySelector('.btn-row').style.display = '';
            document.querySelector('.bonus-breakdown').style.display = '';
            document.getElementById('retry-btn').classList.add('hidden');

            score = 0; enemiesEaten = 0; powered = false; elapsedSeconds = 0;
            startTime = Date.now();
            floatingMessages = [];
            deathFade = 0;
            if (powerTimer) clearTimeout(powerTimer);

            player = { x: 9, y: 15, dx: 0, dy: 0, nextDx: 0, nextDy: 0, munch: 0 };
            enemies = ENEMIES.map((cfg, i) => ({
                ...cfg,
                x: 7 + i * 2,
                y: 9,
                dx: 0,
                dy: 0,
                mc: 0,
                scared: false,
                eaten: false,
                wobble: Math.random() * Math.PI * 2
            }));

            dots = []; powerUps = [];
            for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
                if (MAP[y][x] === 0) dots.push({ x, y });
                if (MAP[y][x] === 2) powerUps.push({ x, y });
            }

            updateHUD();
            gameRunning = true;
            if (animFrame) cancelAnimationFrame(animFrame);
            gameLoop();
        }

        function setupControls() {
            document.addEventListener('keydown', e => {
                if (!gameRunning) return;
                const keys = { ArrowUp: [0,-1], ArrowDown: [0,1], ArrowLeft: [-1,0], ArrowRight: [1,0], w: [0,-1], s: [0,1], a: [-1,0], d: [1,0] };
                if (keys[e.key]) { [player.nextDx, player.nextDy] = keys[e.key]; e.preventDefault(); }
            });
            document.querySelectorAll('.touch-zone').forEach(z => {
                z.addEventListener('touchstart', e => {
                    if (!gameRunning) return;
                    e.preventDefault();
                    const dirs = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] };
                    [player.nextDx, player.nextDy] = dirs[z.dataset.dir];
                }, { passive: false });
            });
            document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        }

        function canMove(x, y) {
            if (x < 0 || x >= COLS) return true;
            if (y < 0 || y >= ROWS) return false;
            return MAP[y][x] !== 1;
        }

        function tryChangeDirection() {
            // Try to change direction immediately if possible (responsive controls)
            if (player.nextDx !== player.dx || player.nextDy !== player.dy) {
                if (canMove(player.x + player.nextDx, player.y + player.nextDy)) {
                    player.dx = player.nextDx;
                    player.dy = player.nextDy;
                }
            }
        }

        function movePlayer() {
            // Direction change is handled separately for responsiveness
            tryChangeDirection();

            if (canMove(player.x + player.dx, player.y + player.dy)) {
                player.x += player.dx; player.y += player.dy;
                player.munch++;
            }
            if (player.x < 0) player.x = COLS - 1;
            if (player.x >= COLS) player.x = 0;

            let idx = dots.findIndex(d => d.x === player.x && d.y === player.y);
            if (idx !== -1) { dots.splice(idx, 1); score += 10; updateHUD(); }

            idx = powerUps.findIndex(p => p.x === player.x && p.y === player.y);
            if (idx !== -1) { powerUps.splice(idx, 1); score += 50; activatePower(); updateHUD(); }

            if (!dots.length && !powerUps.length) { winGame(); }
        }

        function activatePower() {
            powered = true;
            enemies.forEach(e => e.scared = true);
            document.getElementById('power-pill').classList.add('active');
            if (powerTimer) clearTimeout(powerTimer);
            powerTimer = setTimeout(() => {
                powered = false;
                enemies.forEach(e => e.scared = false);
                document.getElementById('power-pill').classList.remove('active');
            }, 6000);
        }

        const SPAWN_X = 9, SPAWN_Y = 7; // Just outside ghost house

        function moveEnemies() {
            enemies.forEach(e => {
                if (e.eaten) {
                    // Return to spawn - simple direct movement, faster
                    if (Math.abs(e.x - SPAWN_X) <= 1 && Math.abs(e.y - SPAWN_Y) <= 1) {
                        e.x = SPAWN_X;
                        e.y = SPAWN_Y;
                        e.eaten = false;
                        e.scared = powered;
                        e.dx = 0;
                        e.dy = 1;
                        e.mc = 0;
                        return;
                    }

                    // Move towards spawn (simple pathfinding, runs every frame for speed)
                    const dx = e.x < SPAWN_X ? 1 : e.x > SPAWN_X ? -1 : 0;
                    const dy = e.y < SPAWN_Y ? 1 : e.y > SPAWN_Y ? -1 : 0;

                    // Try horizontal first, then vertical
                    if (dx !== 0 && canMove(e.x + dx, e.y)) {
                        e.x += dx;
                    } else if (dy !== 0 && canMove(e.x, e.y + dy)) {
                        e.y += dy;
                    } else if (dx !== 0) {
                        // Try vertical if horizontal blocked
                        if (canMove(e.x, e.y - 1)) e.y -= 1;
                        else if (canMove(e.x, e.y + 1)) e.y += 1;
                    } else if (dy !== 0) {
                        // Try horizontal if vertical blocked
                        if (canMove(e.x - 1, e.y)) e.x -= 1;
                        else if (canMove(e.x + 1, e.y)) e.x += 1;
                    }
                    return;
                }

                if (++e.mc < 4 - e.speed) return;
                e.mc = 0;

                const dirs = [[0,-1],[0,1],[-1,0],[1,0]].filter(d =>
                    canMove(e.x+d[0], e.y+d[1]) && !(d[0]===-e.dx && d[1]===-e.dy)
                );

                if (dirs.length) {
                    dirs.sort((a,b) => {
                        const dA = Math.abs(player.x-(e.x+a[0])) + Math.abs(player.y-(e.y+a[1]));
                        const dB = Math.abs(player.x-(e.x+b[0])) + Math.abs(player.y-(e.y+b[1]));
                        return e.scared ? dB - dA : dA - dB; // Flee when scared
                    });
                    const c = Math.random() > 0.3 ? dirs[0] : dirs[Math.floor(Math.random()*dirs.length)];
                    e.dx = c[0]; e.dy = c[1];
                }

                if (canMove(e.x + e.dx, e.y + e.dy)) { e.x += e.dx; e.y += e.dy; }
                if (e.x < 0) e.x = COLS - 1;
                if (e.x >= COLS) e.x = 0;
            });
        }

        function showFloatingMessage(x, y, text, points) {
            floatingMessages.push({
                x: x * CELL + CELL/2,
                y: y * CELL,
                text: text,
                points: points,
                opacity: 1,
                life: 60 // frames
            });
        }

        function checkCollision() {
            enemies.forEach(e => {
                if (e.eaten) return;
                // Check both current position AND if they crossed paths
                const sameCell = e.x === player.x && e.y === player.y;
                // Check if they swapped positions (crossed paths)
                const crossed = (e.x === player.x - player.dx && e.y === player.y - player.dy &&
                                player.x === e.x + e.dx && player.y === e.y + e.dy);

                if (sameCell || crossed) {
                    if (e.scared) {
                        // Delete the file!
                        e.eaten = true;
                        enemiesEaten++;
                        const points = 200 * Math.pow(2, Math.min(enemiesEaten - 1, 3)); // 200, 400, 800, 1600
                        score += points;
                        // Time bonus for eating enemy
                        const eatBonus = 50;
                        score += eatBonus;
                        updateHUD();
                        // Show floating message
                        const msg = EAT_MESSAGES[Math.floor(Math.random() * EAT_MESSAGES.length)];
                        showFloatingMessage(e.x, e.y, msg, points);
                    } else {
                        gameOver();
                    }
                }
            });
        }

        function winGame() {
            gameRunning = false;
            calculateFinalScore(true);
        }

        function gameOver() {
            gameRunning = false;
            deathFade = 0.01; // Start fade
            animFrame = requestAnimationFrame(gameLoop);
        }

        function showGameOver() {
            baseScore = score;
            const timeLeft = Math.max(0, MAX_TIME - elapsedSeconds);
            timeBonus = Math.floor(timeLeft * 10);
            finalScore = baseScore + timeBonus;

            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('final-score').textContent = finalScore.toLocaleString();
            document.getElementById('breakdown').innerHTML = `
                <div class="bonus-row"><span>Data cleaned</span><span>${baseScore.toLocaleString()}</span></div>
                <div class="bonus-row"><span>Files deleted (${enemiesEaten})</span><span>included</span></div>
                <div class="bonus-row"><span>Time bonus</span><span>+${timeBonus.toLocaleString()}</span></div>
            `;
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('player-name').value = '';
        }

        function calculateFinalScore(won) {
            // For win, show immediately
            baseScore = score;
            const timeLeft = Math.max(0, MAX_TIME - elapsedSeconds);
            timeBonus = Math.floor(timeLeft * 10);
            finalScore = baseScore + timeBonus;

            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('final-score').textContent = finalScore.toLocaleString();
            document.getElementById('breakdown').innerHTML = `
                <div class="bonus-row"><span>Data cleaned</span><span>${baseScore.toLocaleString()}</span></div>
                <div class="bonus-row"><span>Files deleted (${enemiesEaten})</span><span>included</span></div>
                <div class="bonus-row"><span>Time bonus</span><span>+${timeBonus.toLocaleString()}</span></div>
            `;
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('player-name').value = '';
        }

        function updateHUD() {
            document.getElementById('hud-score').textContent = score.toLocaleString();
        }

        function updateTimer() {
            elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            const remaining = Math.max(0, MAX_TIME - elapsedSeconds);
            const mins = Math.floor(remaining / 60);
            const secs = remaining % 60;
            const timerEl = document.getElementById('hud-timer');
            timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            timerEl.className = 'hud-timer' + (remaining <= 30 ? ' warning' : '') + (remaining <= 10 ? ' critical' : '');

            // Time's up!
            if (remaining <= 0 && gameRunning) {
                gameOver();
            }
        }

        function draw() {
            // Dark background
            ctx.fillStyle = PATH_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Walls with glow
            ctx.fillStyle = WALL_COLOR;
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 3;
            for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
                if (MAP[y][x] === 1) {
                    ctx.beginPath();
                    ctx.roundRect(x*CELL+1, y*CELL+1, CELL-2, CELL-2, 2);
                    ctx.fill();
                }
            }
            ctx.shadowBlur = 0;

            // Dots (data points)
            ctx.fillStyle = DOT_COLOR;
            dots.forEach(d => {
                ctx.beginPath();
                ctx.arc(d.x*CELL+CELL/2, d.y*CELL+CELL/2, 2, 0, Math.PI*2);
                ctx.fill();
            });

            // Power-ups (pulsing)
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.2;
            ctx.fillStyle = '#3b82f6';
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 8;
            powerUps.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x*CELL+CELL/2, p.y*CELL+CELL/2, 5 * pulse, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Player - Rastro logo pointing in direction of travel
            const px = player.x * CELL + CELL/2;
            const py = player.y * CELL + CELL/2;
            const size = CELL;

            ctx.save();
            ctx.translate(px, py);

            // Point in direction of travel (default: right)
            if (player.dx === -1) ctx.scale(-1, 1); // Flip for left
            else if (player.dy === -1) ctx.rotate(-Math.PI/2); // Up
            else if (player.dy === 1) ctx.rotate(Math.PI/2); // Down

            // Draw actual Rastro logo using the SVG path
            ctx.fillStyle = powered ? '#22c55e' : '#3b82f6';
            ctx.shadowColor = powered ? '#22c55e' : '#3b82f6';
            ctx.shadowBlur = 8;

            // Scale the logo path to fit in cell (original viewBox is 656x656)
            const logoScale = size / 656;
            ctx.scale(logoScale, logoScale);
            ctx.translate(-328, -328); // Center the logo

            // Rastro R logo path
            ctx.beginPath();
            ctx.moveTo(259.891, 249.609);
            ctx.bezierCurveTo(167.663, 278.785, 119.681, 228.948, 124.306, 134.828);
            ctx.bezierCurveTo(126.734, 111.779, 143.355, 104.998, 165.763, 104.744);
            ctx.bezierCurveTo(217.019, 104.089, 277.821, 104.681, 328.423, 104.491);
            ctx.bezierCurveTo(433.195, 99.0821, 526.274, 144, 528.323, 250.962);
            ctx.bezierCurveTo(529.217, 297.629, 511.822, 341.869, 482.741, 376.813);
            ctx.bezierCurveTo(465.487, 397.77, 468.908, 417.503, 481.559, 438.989);
            ctx.bezierCurveTo(494.821, 463.179, 517.018, 493.791, 528.274, 518.446);
            ctx.bezierCurveTo(540.418, 543.206, 528.401, 549.903, 500.904, 551.594);
            ctx.bezierCurveTo(473.047, 552.988, 438.18, 552.946, 409.859, 551.678);
            ctx.bezierCurveTo(387.916, 550.896, 370.007, 543.164, 363.101, 521.594);
            ctx.bezierCurveTo(353.492, 496.199, 346.079, 464.615, 327.684, 442.749);
            ctx.bezierCurveTo(313.851, 424.348, 281.982, 408.545, 266.121, 430.538);
            ctx.bezierCurveTo(241.602, 462.946, 298.898, 527.065, 265.657, 546.227);
            ctx.bezierCurveTo(242.806, 555.481, 182.785, 555.143, 162.257, 544.495);
            ctx.bezierCurveTo(137.484, 530.467, 144.981, 488.678, 143.566, 463.812);
            ctx.bezierCurveTo(144.284, 430.622, 141.919, 396.714, 149.311, 364.073);
            ctx.bezierCurveTo(180.863, 215.933, 379.574, 374.447, 415.329, 268.729);
            ctx.bezierCurveTo(418.729, 246.715, 398.729, 229.771, 378.581, 225.652);
            ctx.bezierCurveTo(337.356, 216.462, 299.574, 238.666, 259.976, 249.588);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;

            // Enemies - Spreadsheet icons
            enemies.forEach(e => {
                const ex = e.x * CELL + CELL/2;
                const ey = e.y * CELL + CELL/2;

                if (e.eaten) {
                    // Just a faded outline when eaten
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(ex - CELL/2 + 2, ey - CELL/2 + 2, CELL - 4, CELL - 4);
                    return;
                }

                const wobble = Math.sin(Date.now() / 150 + e.wobble) * 1.5;

                ctx.save();
                ctx.translate(ex, ey + wobble);

                // Spreadsheet dimensions - almost fill the cell
                const sw = CELL - 2;
                const sh = CELL - 2;

                // Shadow/glow
                ctx.shadowColor = e.scared ? '#3b82f6' : e.bg;
                ctx.shadowBlur = 6;

                // Main spreadsheet body (white or blue when scared)
                ctx.fillStyle = e.scared ? '#1e40af' : '#fff';
                ctx.beginPath();
                ctx.roundRect(-sw/2, -sh/2, sw, sh, 2);
                ctx.fill();

                ctx.shadowBlur = 0;

                // Header row (colored)
                ctx.fillStyle = e.scared ? '#60a5fa' : e.bg;
                ctx.beginPath();
                ctx.roundRect(-sw/2, -sh/2, sw, sh * 0.25, [2, 2, 0, 0]);
                ctx.fill();

                // Grid lines
                ctx.strokeStyle = e.scared ? 'rgba(96,165,250,0.4)' : 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 0.5;

                // Horizontal lines (3 rows)
                for (let i = 1; i <= 3; i++) {
                    const y = -sh/2 + (sh * i / 4);
                    ctx.beginPath();
                    ctx.moveTo(-sw/2, y);
                    ctx.lineTo(sw/2, y);
                    ctx.stroke();
                }

                // Vertical lines (2 columns)
                for (let i = 1; i <= 2; i++) {
                    const x = -sw/2 + (sw * i / 3);
                    ctx.beginPath();
                    ctx.moveTo(x, -sh/2 + sh * 0.25);
                    ctx.lineTo(x, sh/2);
                    ctx.stroke();
                }

                // Extension label in header
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.floor(CELL * 0.28)}px Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(e.label, 0, -sh/2 + sh * 0.125);

                ctx.restore();
            });

            // Floating messages
            floatingMessages = floatingMessages.filter(m => {
                m.life--;
                m.y -= 0.8; // Float up
                m.opacity = m.life / 60;

                if (m.life <= 0) return false;

                ctx.save();
                ctx.globalAlpha = m.opacity;
                ctx.fillStyle = '#22c55e';
                ctx.font = 'bold 10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`+${m.points}`, m.x, m.y);
                ctx.fillStyle = '#fff';
                ctx.font = '8px Inter, sans-serif';
                ctx.fillText(m.text, m.x, m.y + 10);
                ctx.restore();

                return true;
            });
        }

        let lastTime = 0;
        let deathFade = 0; // For fade to black on death

        function gameLoop(ts = 0) {
            if (!gameRunning) {
                // Death fade animation
                if (deathFade > 0 && deathFade < 1) {
                    deathFade += 0.02;
                    draw();
                    // Draw fade overlay
                    ctx.fillStyle = `rgba(15, 23, 42, ${deathFade})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    if (deathFade >= 1) {
                        showGameOver();
                    } else {
                        animFrame = requestAnimationFrame(gameLoop);
                    }
                }
                return;
            }
            updateTimer();
            // Check direction changes every frame for responsiveness
            tryChangeDirection();
            // Game tick - 100ms for balanced speed
            if (ts - lastTime >= 100) {
                movePlayer();
                moveEnemies();
                checkCollision();
                lastTime = ts;
            }
            draw();
            animFrame = requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
