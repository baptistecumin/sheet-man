<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sheet-Man | Rastro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --rastro-blue: #0817EC;
            --blue-600: #2563eb;
            --blue-700: #1d4ed8;
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-600: #475569;
            --slate-700: #334155;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--slate-50);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 16px;
            text-align: center;
            padding: 24px;
            background: var(--slate-50);
        }

        h1 {
            font-size: 32px;
            font-weight: 600;
            color: var(--slate-900);
            letter-spacing: -0.03em;
        }

        .subtitle {
            color: var(--slate-500);
            font-size: 14px;
            font-weight: 400;
        }

        .hint {
            color: var(--slate-400);
            font-size: 12px;
            margin-top: 8px;
        }

        .btn {
            background: var(--blue-600);
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            font-family: inherit;
            border-radius: 8px;
            transition: background 0.15s ease;
        }

        .btn:hover, .btn:active {
            background: var(--blue-700);
        }

        .btn-secondary {
            background: var(--slate-200);
            color: var(--slate-700);
        }

        .btn-secondary:hover {
            background: var(--slate-300);
        }

        .hidden { display: none !important; }

        /* Game container */
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative;
        }

        #score-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 16px;
            background: white;
            border-bottom: 1px solid var(--slate-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        #score {
            font-size: 14px;
            font-weight: 500;
            color: var(--slate-700);
        }

        #score span {
            color: var(--blue-600);
            font-weight: 600;
        }

        #canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
        }

        canvas {
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Touch zones overlay */
        #touch-zones {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            pointer-events: none;
        }

        .touch-zone {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .touch-zone:active {
            opacity: 0.1;
            background: var(--blue-600);
        }

        .touch-zone.top { grid-column: 2; grid-row: 1; }
        .touch-zone.bottom { grid-column: 2; grid-row: 3; }
        .touch-zone.left { grid-column: 1; grid-row: 2; }
        .touch-zone.right { grid-column: 3; grid-row: 2; }

        /* Game Over screen - BSOD style */
        #gameover-screen {
            background: var(--blue-600);
            color: #fff;
            display: none;
        }

        #gameover-screen h1 {
            color: #fff;
            font-size: 24px;
        }

        #gameover-screen p {
            color: rgba(255,255,255,0.9);
            font-size: 14px;
            max-width: 320px;
        }

        #final-score {
            font-size: 18px;
            font-weight: 600;
            margin: 8px 0;
        }

        /* Leaderboard */
        #leaderboard {
            background: white;
            border-radius: 8px;
            padding: 16px;
            width: 100%;
            max-width: 280px;
            margin-top: 16px;
        }

        #leaderboard h2 {
            font-size: 12px;
            font-weight: 500;
            color: var(--slate-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
        }

        .leaderboard-list {
            list-style: none;
        }

        .leaderboard-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--slate-100);
            font-size: 13px;
        }

        .leaderboard-list li:last-child {
            border-bottom: none;
        }

        .leaderboard-list .rank {
            color: var(--slate-400);
            width: 24px;
        }

        .leaderboard-list .name {
            flex: 1;
            color: var(--slate-700);
        }

        .leaderboard-list .lb-score {
            color: var(--blue-600);
            font-weight: 500;
        }

        /* Name input */
        #name-input-container {
            display: none;
            flex-direction: column;
            gap: 12px;
            margin-top: 16px;
        }

        #name-input-container input {
            padding: 10px 14px;
            border: 1px solid var(--slate-300);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            text-align: center;
            width: 200px;
        }

        #name-input-container input:focus {
            outline: none;
            border-color: var(--blue-600);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        /* Power indicator */
        #power-indicator {
            position: absolute;
            top: 56px;
            left: 50%;
            transform: translateX(-50%);
            background: #10b981;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.2s;
        }

        #power-indicator.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="start-screen" class="screen">
        <h1>Sheet-Man</h1>
        <p class="subtitle">Don't let the spreadsheets crash you.</p>
        <p class="hint">Tap screen edges or use arrow keys</p>
        <button class="btn" onclick="startGame()">Start Cleaning</button>

        <div id="leaderboard">
            <h2>Leaderboard</h2>
            <ul class="leaderboard-list" id="leaderboard-list">
                <li><span class="rank">-</span><span class="name">Loading...</span><span class="lb-score"></span></li>
            </ul>
        </div>
    </div>

    <div id="gameover-screen" class="screen">
        <h1>:( Critical Error</h1>
        <p>The Excel file was too large.</p>
        <p id="final-score">SKUs Cleaned: 0</p>

        <div id="name-input-container">
            <input type="text" id="player-name" placeholder="Your name" maxlength="20" autocomplete="off">
            <div class="btn-row">
                <button class="btn" onclick="submitScore()">Submit</button>
                <button class="btn btn-secondary" onclick="skipSubmit()">Skip</button>
            </div>
        </div>

        <button id="retry-btn" class="btn hidden" onclick="startGame()">Try Again</button>

        <p class="hint" style="margin-top:16px;">Stop playing games with your data.<br>Rastro cleans catalogs automatically.</p>
    </div>

    <div id="game-container" class="hidden">
        <div id="score-bar">
            <span id="score">SKUs Cleaned: <span id="score-value">0</span></span>
            <span id="powered-badge" style="display:none;background:#10b981;color:white;padding:2px 8px;border-radius:4px;font-size:11px;">POWERED</span>
        </div>
        <div id="canvas-wrapper">
            <canvas id="canvas"></canvas>
            <div id="touch-zones">
                <div class="touch-zone top" data-dir="up"></div>
                <div class="touch-zone left" data-dir="left"></div>
                <div class="touch-zone right" data-dir="right"></div>
                <div class="touch-zone bottom" data-dir="down"></div>
            </div>
        </div>
    </div>

    <script>
        // Supabase config
        const SUPABASE_URL = 'https://pkbcifdmebszcrpmlhxm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBrYmNpZmRtZWJzemNycG1saHhtIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NTQ0MzkwMCwiZXhwIjoyMDgxMDE5OTAwfQ.oxMxEUp7svTv_AXJC0-cLUWE7nOt5p_u2Ahxxiv98Fk';

        // Game constants
        const CELL = 18;
        const COLS = 19;
        const ROWS = 21;

        const MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,2,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];

        let canvas, ctx;
        let player, enemies, dots, powerUps;
        let score = 0;
        let gameRunning = false;
        let powered = false;
        let powerTimer = null;
        let animFrame;
        let finalScore = 0;

        const ENEMIES_CONFIG = [
            { name: 'XLS', color: '#22c55e', speed: 3 },
            { name: 'PDF', color: '#ef4444', speed: 2 },
            { name: 'ERP', color: '#64748b', speed: 1 },
            { name: 'ZIP', color: '#eab308', speed: 2 },
        ];

        // Leaderboard functions
        async function fetchLeaderboard() {
            try {
                const res = await fetch(
                    `${SUPABASE_URL}/rest/v1/sheetman_leaderboard?select=name,score&order=score.desc&limit=5`,
                    {
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`
                        }
                    }
                );
                if (!res.ok) throw new Error('Failed to fetch');
                const data = await res.json();
                renderLeaderboard(data);
            } catch (e) {
                console.log('Leaderboard not available');
                renderLeaderboard([]);
            }
        }

        function renderLeaderboard(data) {
            const list = document.getElementById('leaderboard-list');
            if (!data || data.length === 0) {
                list.innerHTML = '<li><span class="rank">-</span><span class="name">No scores yet</span><span class="lb-score"></span></li>';
                return;
            }
            list.innerHTML = data.map((entry, i) =>
                `<li><span class="rank">${i + 1}.</span><span class="name">${escapeHtml(entry.name)}</span><span class="lb-score">${entry.score}</span></li>`
            ).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function saveScore(name, score) {
            try {
                await fetch(`${SUPABASE_URL}/rest/v1/sheetman_leaderboard`, {
                    method: 'POST',
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({ name, score })
                });
                fetchLeaderboard();
            } catch (e) {
                console.log('Could not save score');
            }
        }

        function submitScore() {
            const nameInput = document.getElementById('player-name');
            const name = nameInput.value.trim() || 'Anonymous';
            saveScore(name, finalScore);
            document.getElementById('name-input-container').style.display = 'none';
            document.getElementById('retry-btn').classList.remove('hidden');
        }

        function skipSubmit() {
            document.getElementById('name-input-container').style.display = 'none';
            document.getElementById('retry-btn').classList.remove('hidden');
        }

        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Size canvas to fit screen
            const maxWidth = Math.min(window.innerWidth - 32, 380);
            const maxHeight = window.innerHeight - 120;
            const scale = Math.min(maxWidth / (COLS * CELL), maxHeight / (ROWS * CELL));
            canvas.width = COLS * CELL;
            canvas.height = ROWS * CELL;
            canvas.style.width = (COLS * CELL * scale) + 'px';
            canvas.style.height = (ROWS * CELL * scale) + 'px';

            setupControls();
            fetchLeaderboard();
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('game-container').classList.remove('hidden');
            document.getElementById('name-input-container').style.display = 'none';
            document.getElementById('retry-btn').classList.add('hidden');

            score = 0;
            powered = false;
            if (powerTimer) clearTimeout(powerTimer);

            player = { x: 9, y: 15, dx: 0, dy: 0, nextDx: 0, nextDy: 0 };

            enemies = ENEMIES_CONFIG.map((cfg, i) => ({
                ...cfg,
                x: 8 + i,
                y: 9,
                dx: Math.random() > 0.5 ? 1 : -1,
                dy: 0,
                moveCounter: 0
            }));

            dots = [];
            powerUps = [];
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (MAP[y][x] === 0) dots.push({ x, y });
                    if (MAP[y][x] === 2) powerUps.push({ x, y });
                }
            }

            updateScore();
            gameRunning = true;
            if (animFrame) cancelAnimationFrame(animFrame);
            gameLoop();
        }

        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', e => {
                if (!gameRunning) return;
                switch(e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        player.nextDx = 0; player.nextDy = -1; break;
                    case 'ArrowDown': case 's': case 'S':
                        player.nextDx = 0; player.nextDy = 1; break;
                    case 'ArrowLeft': case 'a': case 'A':
                        player.nextDx = -1; player.nextDy = 0; break;
                    case 'ArrowRight': case 'd': case 'D':
                        player.nextDx = 1; player.nextDy = 0; break;
                }
                e.preventDefault();
            });

            // Touch zones
            document.querySelectorAll('.touch-zone').forEach(zone => {
                zone.addEventListener('touchstart', e => {
                    if (!gameRunning) return;
                    e.preventDefault();
                    const dir = zone.dataset.dir;
                    switch(dir) {
                        case 'up': player.nextDx = 0; player.nextDy = -1; break;
                        case 'down': player.nextDx = 0; player.nextDy = 1; break;
                        case 'left': player.nextDx = -1; player.nextDy = 0; break;
                        case 'right': player.nextDx = 1; player.nextDy = 0; break;
                    }
                }, { passive: false });
            });

            // Prevent scrolling
            document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        }

        function canMove(x, y) {
            if (x < 0 || x >= COLS) return true;
            if (y < 0 || y >= ROWS) return false;
            return MAP[y][x] !== 1;
        }

        function movePlayer() {
            if (canMove(player.x + player.nextDx, player.y + player.nextDy)) {
                player.dx = player.nextDx;
                player.dy = player.nextDy;
            }

            if (canMove(player.x + player.dx, player.y + player.dy)) {
                player.x += player.dx;
                player.y += player.dy;
            }

            if (player.x < 0) player.x = COLS - 1;
            if (player.x >= COLS) player.x = 0;

            const dotIdx = dots.findIndex(d => d.x === player.x && d.y === player.y);
            if (dotIdx !== -1) {
                dots.splice(dotIdx, 1);
                score += 10;
                updateScore();
            }

            const puIdx = powerUps.findIndex(p => p.x === player.x && p.y === player.y);
            if (puIdx !== -1) {
                powerUps.splice(puIdx, 1);
                score += 50;
                updateScore();
                activatePower();
            }

            if (dots.length === 0 && powerUps.length === 0) {
                gameRunning = false;
                score += 500; // Bonus for completing
                gameOver();
            }
        }

        function activatePower() {
            powered = true;
            document.getElementById('powered-badge').style.display = 'inline';
            if (powerTimer) clearTimeout(powerTimer);
            powerTimer = setTimeout(() => {
                powered = false;
                document.getElementById('powered-badge').style.display = 'none';
            }, 5000);
        }

        function moveEnemies() {
            enemies.forEach(enemy => {
                enemy.moveCounter++;
                if (enemy.moveCounter < (4 - enemy.speed)) return;
                enemy.moveCounter = 0;

                const dirs = [[0,-1],[0,1],[-1,0],[1,0]].filter(
                    d => canMove(enemy.x + d[0], enemy.y + d[1]) &&
                         !(d[0] === -enemy.dx && d[1] === -enemy.dy)
                );

                if (dirs.length > 0) {
                    dirs.sort((a, b) => {
                        const distA = Math.abs(player.x - (enemy.x + a[0])) + Math.abs(player.y - (enemy.y + a[1]));
                        const distB = Math.abs(player.x - (enemy.x + b[0])) + Math.abs(player.y - (enemy.y + b[1]));
                        return powered ? distB - distA : distA - distB;
                    });
                    const choice = Math.random() > 0.3 ? dirs[0] : dirs[Math.floor(Math.random() * dirs.length)];
                    enemy.dx = choice[0];
                    enemy.dy = choice[1];
                }

                if (canMove(enemy.x + enemy.dx, enemy.y + enemy.dy)) {
                    enemy.x += enemy.dx;
                    enemy.y += enemy.dy;
                }

                if (enemy.x < 0) enemy.x = COLS - 1;
                if (enemy.x >= COLS) enemy.x = 0;
            });
        }

        function checkCollision() {
            enemies.forEach(enemy => {
                if (enemy.x === player.x && enemy.y === player.y) {
                    if (powered) {
                        enemy.x = 9;
                        enemy.y = 9;
                        score += 200;
                        updateScore();
                    } else {
                        gameOver();
                    }
                }
            });
        }

        function gameOver() {
            gameRunning = false;
            finalScore = score;
            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('final-score').textContent = 'SKUs Cleaned: ' + score;
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('name-input-container').style.display = 'flex';
            document.getElementById('player-name').value = '';
            document.getElementById('player-name').focus();
        }

        function updateScore() {
            document.getElementById('score-value').textContent = score;
        }

        function draw() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL, 0);
                ctx.lineTo(x * CELL, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL);
                ctx.lineTo(canvas.width, y * CELL);
                ctx.stroke();
            }

            // Walls
            ctx.fillStyle = '#1e293b';
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (MAP[y][x] === 1) {
                        ctx.fillRect(x * CELL + 1, y * CELL + 1, CELL - 2, CELL - 2);
                    }
                }
            }

            // Dots
            ctx.fillStyle = '#94a3b8';
            dots.forEach(d => {
                ctx.beginPath();
                ctx.arc(d.x * CELL + CELL/2, d.y * CELL + CELL/2, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Power-ups
            ctx.fillStyle = '#2563eb';
            powerUps.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x * CELL + CELL/2, p.y * CELL + CELL/2, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Player
            ctx.fillStyle = powered ? '#10b981' : '#2563eb';
            ctx.beginPath();
            ctx.arc(player.x * CELL + CELL/2, player.y * CELL + CELL/2, CELL/2 - 2, 0, Math.PI * 2);
            ctx.fill();

            // Enemies
            enemies.forEach(e => {
                ctx.fillStyle = powered ? '#cbd5e1' : e.color;
                ctx.fillRect(e.x * CELL + 2, e.y * CELL + 2, CELL - 4, CELL - 4);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 8px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(e.name, e.x * CELL + CELL/2, e.y * CELL + CELL/2 + 3);
            });
            ctx.textAlign = 'left';
        }

        let lastTime = 0;
        const TICK = 140;

        function gameLoop(timestamp = 0) {
            if (!gameRunning) return;

            if (timestamp - lastTime >= TICK) {
                movePlayer();
                moveEnemies();
                checkCollision();
                lastTime = timestamp;
            }

            draw();
            animFrame = requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
